
<img width="1000" alt="스크린샷 2024-08-05 오전 4 49 51" src="https://github.com/user-attachments/assets/5d2196a0-6934-4a78-9129-26ef07aaf042">


<br/><br/>

## 목차
- [프로젝트 소개](#프로젝트-소개)
- [팀 구성 및 역할](#팀-구성-및-역할)
- [기술 스택](#기술-스택)
- [주요 기능 실행 화면](#주요-기능-실행-화면)
- [주요 기술](#주요-기술)
- [트러블슈팅](#트러블슈팅)
- [회고](#회고)
- [유지보수 계획](#유지보수-계획)

<br/><br/>

## 프로젝트 소개

### **배줄이**
배달 음식 소비지출을 기록하면 매주 절약한 금액을 확인할 수 있는 배달 음식 줄이기 도우미 서비스입니다.
사용자가 집에 있는 재료를 입력하면 AI가 맞춤 요리를 추천해주어 배달 음식 줄이기를 도와줄 수 있습니다.

### **기능**

- 💲 이번주 절약 금액 조회
- 🏍️ 이번주 배달 횟수 조회
- 📝 식사 기록
- 🥗 레시피 추천받기

<br/><br/>

## 팀 구성 및 역할
1인 기획, 디자인, 개발

<br/><br/>

## 기술 스택

- **언어:** `Swift`
- **프레임워크:** `UIKit`
- 아키텍쳐: `MVVM`
- 반응형 프로그래밍: `Custom Observable`
- **사용한 라이브러리:**
    - `Alamofire`
    - `KingFisher`
    - `Realm`
    - `SnapKit`
    - `Then`
    - `Toast`
    
<br/><br/>

## 주요 기능 실행 화면

**1) 식사 기록 & 절약 금액 및 배달 횟수 조회**

사용자가 선택한 날짜, 식사 시간, 식사 타입 및 가격을 Realm에 저장합니다. Realm Notification를 통해 
데이터 변경 시 절약 금액과 배달 횟수가 자동으로 업데이트되며, 이 정보는 Observable을 통해 UI에 즉시 반영됩니다.



https://github.com/user-attachments/assets/f30c8553-ff21-4374-a4d3-4dedb0a478c6



<br/>

**2) 레시피 추천**
- 재료 선택의 경우, Singleton Pattern을 사용하여 선택된 재료 목록을 중앙에서 관리하고, 최대 선택 가능 수를 제한하여 유효성을 검사하도록 구현하였습니다. 상태 변경 시 NotificationCenter를 통해 관련 UI를 업데이트하였습니다.
- 레시피 추천의 경우, AI 모델에서 추천 요리 목록을 받아온 후, REST API를 이용하여 CustomSearchAPI를 통해 요리 이미지를 요청합니다. 응답값을 UICollectionView에 반영하며, 로딩 중에는 LottieAnimation로 로딩 애니메이션을 보여주도록 구현하였습니다.



https://github.com/user-attachments/assets/e809ea75-26d5-4024-819a-499645a39005






<br/><br/>

## 주요 기술

**디자인 패턴**

- ViewModel에 **Input-Output 패턴**을 적용하여 데이터의 흐름을 단방향으로 관리하였습니다.
- Repository Pattern을 이용하여 Realm method를 관리해 코드 구조를 명확하게 유지하고 재사용성을 높였습니다.
- Singleton Pattern을 활용하여 데이터를 중앙에서 관리하고 재사용성을 높였습니다.

  <br/>

**비동기 프로그래밍 및 네트워크 처리**

- Custom Observable을 사용하여 데이터 스트림을 유연하게 관리하고, 비동기 작업을 처리하였습니다.
- async/await를 활용하여 비동기 작업을 효율적으로 관리하고 가독성을 높였습니다.

<br/>

**데이터 관리**

- PK를 사용하여 각 객체를 고유하게 식별하고, FK를 사용하여 객체 간 관계를 표현하여 데이터의 일관성을 유지했습니다.
- 데이터 구조 변경 시, 기존 데이터를 안전하게 마이그레이션하여 데이터베이스의 일관성을 유지했습니다.
- Realm Notification을 사용하여 실시간 데이터 변경을 감지하고 UI를 자동으로 업데이트했습니다.

<br/>

**디버깅**

- Instrument를 활용하여 메모리 누수 여부를 검토하고 최적화 작업을 수행했습니다.
- 디버깅과 실행 중 상태 분석을 위해 LLDB를 활용하여 런타임에 변수 값을 확인하고 코드 실행을 제어했습니다.

<br/>

**UI**

- Compositional Layout을 이용해 CollectionView를 구성했습니다.

<br/><br/>

## 트러블슈팅

### 네트워킹 응답 지연에 대한 대응

**문제 상황**

AI 모델에서 레시피 데이터를 받은 후, 이미지 검색 API를 통해 해당 요리의 이미지를 가져오는 과정에서, 네트워크 응답 지연이 
발생했습니다. 응답값을 받아오는데 평균 5초가 소요되었으며, 이로 인해 사용자에게 긴 대기 시간이 발생했습니다. 
여러 비동기 작업이 동시에 발생하므로, 이들을 효율적으로 관리하고 모든 작업이 완료될 때까지 기다리면서도, 코드 구조를 
복잡하게 만들지 않기 위한 방안이 필요했습니다.
<br/>

**해결 방법**

모든 작업이 완료될 때까지 대기하면서도 코드의 복잡성을 최소화하기 위해 async/await 패턴을 활용했습니다. 여러 비동기 API 
호출을 async 함수 내에서 await 키워드를 통해 처리하고, 각 호출이 완료될 때까지 기다리도록 했습니다. 또한, 로딩 중에는 로티
애니메이션을 표시하고, 성공 시 애니메이션을 멈춘 후, 응답 결과를 CollectionView에 반영하여 향상된 UI/UX를 제공했습니다.


<br/><br/>

## 회고
처음으로 제가 만든 앱을 출시해보는 경험을 할 수 있어서 너무 좋았습니다. 특히 기획, 디자인, 개발을 모두 혼자서 담당하면서 프로젝트에 대해 애정이 컸고, 책임감을 높일 수 있었습니다. 그리고 기획과 디자인이 매우 어렵다는 것도 깨닫게 되었습니다.. 
<br/><br/>
개발적으로는, 이번에 처음으로 MVVM 아키텍처 패턴을 구현해보았습니다. MVVM을 도입해보니 코드 수정이 필요한 경우 MVC보다 비교적 용이하게 변경할 수 있었습니다. 또한, Custom Observable을 사용해 데이터 변화에 따른 UI 업데이트를 기존의 방식(ex. NotificationCenter)보다 더욱 일관되고 효율적으로 처리할 수 있었습니다.
또한, 비동기 작업 처리에서는 async/await를 통해 네트워크 요청과 데이터 처리를 효율적으로 관리할 수 있었고, 이를 통해 사용자에게 매끄러운 UI/UX를 제공할 수 있었습니다. 
<br/><br/>
개선해야 할 부분도 존재합니다. 네트워크 응답 지연 문제를 해결하기 위해 추가적인 비동기 작업 최적화가 필요함을 느꼈고, 이미 개발한 Custom Observable로는 복잡한 비동기 작업의 흐름과 에러 처리를 체계적으로 관리하기 어려웠습니다. 따라서 보다 효율적이고 강력한 비동기 작업 처리를 위해 RxSwift로 리팩토링할 계획입니다. 

<br/><br/>

## 유지보수 계획

- RxSwift로 리팩토링
- 네트워크 코드 모듈화
- 식사 기록 확인 기능 추가
- 통계 기능 추가
